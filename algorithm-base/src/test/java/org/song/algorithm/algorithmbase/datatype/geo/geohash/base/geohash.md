# GEO hash 

# 1. 二维空间索引问题

```markdown
常见的带有索引方便查找的树结构, 比如树, 跳表, 二分查找, hash表等, 他们的数据都是0维(hash表), 要么是一维(树, 跳表), 而地理空间坐标本质上是二维结构, 所以上述方式均不适合处理GEO索引问题
```



# 2. GEO hash 算法

```markdown
采用Z阶曲线, 数学中的分形几何, 数学原理参见: https://www.jianshu.com/p/7332dcb978b2
```

## 1. 二维平面拆分

```markdown
1. 采用二分法将经纬度坐标分成多个等级, 一般分为1~12级, 可以更高
2. 等级越高表示精度越高, 每个等级都将平面分成两部分, 
    纬线: 左边(东半球)/负角度标记为0, 右边(西半球)/正角度标记为1
    经线: 下边(南半球)/负角度标记为0, 上边(北半球)/正角度标记为1
3. 将精度和纬度的编码交叉编排在一起, 按照"偶数位放经度，奇数位放纬度"的规则

这样, 地球上任何一个坐标点都可以用不同的精度矩形来表示, 对应着不同的经纬编码,
将不同的等级由低到高串起来, 则编码越靠后精度越高, 编码越靠前精度越低, 如果两个坐标点都转成编码, 则他们的前缀重合度越高, 则他们距离越近, 他们形成的曲线就是z阶曲线, 
```



| code长度(等级) | cell 宽度 | 角度编码(纬度0)                         | cell 高度 | 角度编码(经度0)                           |
| -------------- | --------- | --------------------------------------- | --------- | ----------------------------------------- |
| 1              | 5,000km   | -180~0 = 0<br/>0~180 = 1                | 5,000km   | -90~0 = 0<br/>0~90 = 1                    |
| 2              | 1,250km   | -90~0 = 0<br/>0~90 = 1                  | 625km     | -45~0 = 0<br/>0~45= 1                     |
| 3              | 156km     | -45~0 = 0<br/>0~45= 1                   | 156km     | -22.5~0 = 0<br/>0~22.5= 1                 |
| 4              | 39.1km    | -22.5~0 = 0<br/>0~22.5= 1               | 19.5km    | -11.25~0 = 0<br/>0~11.25= 1               |
| 5              | 4.89km    | -11.25~0 = 0<br/>0~11.25= 1             | 4.89km    | -5.625~0 = 0<br/>0~5.625= 1               |
| 6              | 1.22km    | -5.625~0 = 0<br/>0~5.625= 1             | 0.61km    | -2.8125~0 = 0<br/>0~2.8125= 1             |
| 7              | 153m      | -2.8125~0 = 0<br/>0~2.8125= 1           | 153m      | -1.40625~0 = 0<br/>0~1.40625= 1           |
| 8              | 38.2m     | -1.40625~0 = 0<br/>0~1.40625= 1         | 19.1m     | -0.73125~0 = 0<br/>0~0.73125= 1           |
| 9              | 4.77m     | -0.73125~0 = 0<br/>0~0.73125= 1         | 4.77m     | -0.3515625~0 = 0<br/>0~0.3515625= 1       |
| 10             | 1.19m     | -0.3515625~0 = 0<br/>0~0.3515625= 1     | 0.596m    | -0.17578125~0 = 0<br/>0~0.17578125= 1     |
| 11             | 149mm     | -0.17578125~0 = 0<br/>0~0.17578125= 1   | 149mm     | -0.087890625~0 = 0<br/>0~0.087890625= 1   |
| 12             | 37.2mm    | -0.087890625~0 = 0<br/>0~0.087890625= 1 | 18.6mm    | -0.0439453125~0 = 0<br/>0~0.0439453125= 1 |

## 2. 编码

```markdown
上个图表中, 如果将等级分为12个等级, 分别用12个bit位表示, 经纬度放在一起总共24个bit位, 完全可以使用一个int来表示
如果仅仅使用int来保存所有的code, 则最多可以分为16级
```

### 1. int编码

```markdown
由于是前缀对比, 所以bit位的前缀要保持对齐, 采用int高位第8(32-24)位开始存入编码, 低位如果没有计算就补0
这样就形成了一个在int范围内的一维的数, 数之间的距离越近, 则表示真实空间他们所处的点距离就越近
```

### 2. 字符编码

**Base32**

|         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Decimal | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| Base 32 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | b    | c    | d    | e    | f    | g    |
| Decimal | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   |
| Base 32 | h    | j    | k    | m    | n    | p    | q    | r    | s    | t    | u    | v    | w    | x    | y    | z    |

```markdown
将组成的二进制位, 每5位编成一组, 5位的bit最多表示32个数, 和base32中一一对应

示例: 假设最高精度等级16
xxxxxxx: 7位base32最多可以表示16级精度(最后一位取值的不同, 可以表示细分下任意范围)
xxxxxx: 6位base32最多可以表示15级精度(最后一位取值的不同, 可以表示细分下任意范围)
xxxxx: 5位base32最多可以表示14级精度(最后一位取值的不同, 可以表示细分下任意范围)
```

**Base36**

```markdown
其他编码方式, Base36 略
```

## 3. GEO hash 算法缺点

```markdown
将二维空间近似成一维本身是一种近似算法, 在z阶曲线中, 两个不同的块交接的时候, 会有距离上的偏差, 如果是大块这种偏差会更明显, 即使他们在一维线上的距离只有1
解决方式:
	1. 在实际应用中, 通常采用GEOHash+坐标直线计算的复合计算方式, 先用Geohash算出复合距离的所有的点, 然后通过直线计算排除误差的点
	2. 采用更先进的S2算法, 看不懂
```



# 3. GEO算法的应用

```markdown
1. 在线GEO展示
https://ryan-miao.gitee.io/geohash-visualization/show_all.html

2. 附近坐标点的查询
```


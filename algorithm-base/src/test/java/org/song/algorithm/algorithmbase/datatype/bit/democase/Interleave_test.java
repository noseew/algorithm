package org.song.algorithm.algorithmbase.datatype.bit.democase;

import org.junit.jupiter.api.Test;
import org.song.algorithm.algorithmbase.utils.BinaryUtils;

public class Interleave_test {
    
    @Test
    public void test() {
        System.out.println(BinaryUtils.binaryPretty(0x0000_FFFF_0000_FFFFL));
    }

    /**
     * 将两个32位的数, 按照bit位交叉成64bit的数
     * 效率O(logn), n = 总bit位数, 由于固定是64位, 所以可以理解为O(1)
     * 
     * @param xOlg
     * @param yOlg
     * @return
     */
    public long interleave(int xOlg, int yOlg) {
        long _16 = 0x0000_FFFF_0000_FFFFL; // 00000000_00000000 11111111_11111111 00000000_00000000 11111111_11111111
        long _8 = 0x00FF_00FF_00FF_00FFL; // 00000000_11111111 00000000_11111111 00000000_11111111 00000000_11111111
        long _4 = 0x0F0F_0F0F_0F0F_0F0FL; // 00001111_00001111 00001111_00001111 00001111_00001111 00001111_00001111
        long _2 = 0x3333_3333_3333_3333L; // 00110011_00110011 00110011_00110011 00110011_00110011 00110011_00110011
        long _1 = 0x5555_5555_5555_5555L; // 01010101_01010101 01010101_01010101 01010101_01010101 01010101_01010101
        
        long x = xOlg;
        long y = yOlg;

        /*
        原始数据从每16位开始二分, 左边左移到32位开始(从低位计算)
        示例:
            原始数据 x  = 0000_0000 0000_0000 1111_1111 1111_1111
            (x << 16) = 1111_1111 1111_1111 0000_0000 0000_0000
            | x       = 1111_1111 1111_1111 1111_1111 1111_1111
            & _16     = 0000_0000 0000_0000 1111_1111 1111_1111
         */
        x = ((x << 16) | x) & _16;
        y = ((y << 16) | y) & _16;

        /*
        原始数据从每8位开始二分, 左边左移到16位开始(从低位计算)
        示例:
            原始数据 x  = 0000_0000 0000_0000 1111_1111 1111_1111
            (x << 8)  = 0000_0000 1111_1111 1111_1111 0000_0000
            | x       = 0000_0000 1111_1111 1111_1111 1111_1111
            & _8      = 0000_0000 1111_1111 0000_0000 1111_1111
        
         */
        x = ((x << 8) | x) & _8;
        y = ((y << 8) | y) & _8;

        /*
        原始数据从每4位开始二分, 左边左移到8位开始(从低位计算)
        示例:
            原始数据 x  = 0000_0000 1111_1111 0000_0000 1111_1111
            (x << 4)  = 0000_1111 1111_0000 0000_1111 1111_0000
            | x       = 0000_1111 1111_1111 1111_1111 1111_1111
            & _4      = 0000_1111 0000_1111 0000_1111 0000_1111
         */
        x = ((x << 4) | x) & _4;
        y = ((y << 4) | y) & _4;

        x = ((x << 2) | x) & _2;
        y = ((y << 2) | y) & _2;

        x = ((x << 1) | x) & _1;
        y = ((y << 1) | y) & _1;
        /*
        以此类推, 最终将原始32bit均匀的分在64bit中, 同时间隔补0
        其中一个数, 左移一位然后拼接
         */

        return x | (y << 1);
    }

    /**
     * 将一个64位的数, 按照bit位交叉换成两个32位的数, 并前后拼成64bit的数
     * 
     * @param xOlg
     * @return
     */
    public long deinterleave(long xOlg) {
        long _32 = 0x0000_0000_FFFF_FFFFL; // 00000000_00000000 00000000_00000000 11111111_11111111 11111111_11111111
        long _16 = 0x0000_FFFF_0000_FFFFL; // 00000000_00000000 11111111_11111111 00000000_00000000 11111111_11111111
        long _8 = 0x00FF_00FF_00FF_00FFL; // 00000000_11111111 00000000_11111111 00000000_11111111 00000000_11111111
        long _4 = 0x0F0F_0F0F_0F0F_0F0FL; // 00001111_00001111 00001111_00001111 00001111_00001111 00001111_00001111
        long _2 = 0x3333_3333_3333_3333L; // 00110011_00110011 00110011_00110011 00110011_00110011 00110011_00110011
        long _1 = 0x5555_5555_5555_5555L; // 01010101_01010101 01010101_01010101 01010101_01010101 01010101_01010101

        long x = xOlg;
        long y = xOlg >>> 1;

        return 0;
    }
}

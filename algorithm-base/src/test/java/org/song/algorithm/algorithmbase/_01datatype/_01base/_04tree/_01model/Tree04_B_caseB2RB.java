package org.song.algorithm.algorithmbase._01datatype._01base._04tree._01model;

/*
B树转红黑树图例
    3阶B树=23树=左倾红黑树
    4阶B树=234树=红黑树(经典)

23树, 3阶B树
每个节点最多有2个v, 每个节点最多有3个子节点

等价红黑树
2-3树是比较早期的一个平衡树, 跟2-3-4树差不多, 编程起来稍微麻烦点, 也是被红黑树取代了. 
2-3查找树的原理很简单, 甚至说代码实现起来难度都不是很大, 但是却很繁琐, 因为它有很多种情况, 而在红黑树中, 用巧妙的方法使用了2个结点解决了3个结点的问题. 

但是, 我们和真正的实现还有一段距离. 
尽管我们可以用不同的数据类型表示2-结点和3-结点并写出变换所需的代码, 但用这种直白的表示方法实现大多数的操作并不方便, 
因为需要处理的情况实在太多. 我们需要维护两种不同类型的结点, 将被查找的键和结点中的每个键进行比较, 
将链接和其他信息从一种结点复制到另一种结点, 将结点从一种数据类型转换到另一种数据类型, 等等. 
实现这些不仅需要大量的代码, 而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢. 
平衡一棵树的初衷是为了消除最坏情况, 但我们希望这种保障所需的代码能够越少越好. 
幸运的是你将看到, 我们只需要一点点代价就能用一种统一的方式完成所有变换. 

这里放入23树的原因是, 红黑树是23树的一个变种, 23树的一些特性可以更好的理解红黑树的特性比如, 变色旋转等

具体不做测试
 */
/*
23树
1. 平衡状态下, 一个节点最多可以保存2个v, 每个节点最多可以有3个子节点c, 其他和二叉树一样
    他们可以由数组方式存储, 提高访问效率, [v1, v2] [c1, c2, c3]
    2个v和3个c示例如下, 
        v1,v2
        / | \
       c1 c2 c3
   按照顺序排列
        c1 < v1 < c2 < v2 < c3
2. 平衡状态下, 左右高度相同, 在极端情况下, 假设root, 所有左子节点都有2个v和3个c, 所有右子节点都是满二叉树
    那么: 
    左子树, 每层节点数=3^h, 每层v数量=2*3^h
    右子树, 每层节点数=2^h, 每层v数量=2^h
    左子树每层v数量-右子树每层v数量=
        h=0, v多 3 - 1 = 2
        h=1, v多 6 - 2 = 4
        h=2, v多 18 - 4 = 14
    由于高度相同, 所以查找效率相同, 从而达到平衡的目的
3. 23树变成2叉树, 方式有很多, 这里采用变成红黑树的方式
        v1,v2
        / | \
       c1 c2 c3
       将左节点分出, 转变为
         v1 == v2
        /  \    \
       c1  c2   c3
       最终转变为
            v2
          //  \
        v1(红) c3
        /  \
       c1  c2
    上图中, // 双线链指向的子节点表示为红色节点, 其他节点表示为黑色节点

下面的代码实现来自于网络, 未测试
 */

/*
234树, 4阶B树
每个节点最多有3个v, 每个节点最多有4个子节点


等价红黑树
具体不做测试
 */
/*
234树
1. 平衡状态下, 一个节点最多可以保存3个v, 每个节点最多可以有4个子节点c, 其他和二叉树一样
    他们可以由数组方式存储, 提高访问效率, [v1, v2, v3] [c1, c2, c3, c4]
    2个v和3个c示例如下, 
        v1,v2,v3
       /  |  |  \
      c1  c2 c3  c4
   按照顺序排列
        c1 < v1 < c2 < v2 < c3 < v3 < c4
2. 平衡状态下, 左右高度相同, 在极端情况下, 假设root, 所有左子节点都有2个v和3个c, 所有右子节点都是满二叉树
    那么: 
    左子树, 每层节点数=4^h, 每层v数量=3*4^h
    右子树, 每层节点数=2^h, 每层v数量=2^h
    左子树每层v数量-右子树每层v数量=
        h=0, v多 4 - 1 = 3
        h=1, v多 14 - 2 = 14
        h=2, v多 64 - 4 = 60
    由于高度相同, 所以查找效率相同, 从而达到平衡的目的
3. 23树变成2叉树, 方式有很多, 这里采用变成红黑树的方式
        v1,v2,v3
       /  |  |  \
      c1  c2 c3  c4
       将左右节点分出, 转变为
         v1 == v2 == v3
        /  \        /  \
       c1  c2      c3  c4
       最终转变为
            v2
          //  \\
       v1(红)  c3(红)
        /  \    /  \
       c1  c2  c3  c4
    上图中, // 双线链指向的子节点表示为红色节点, 其他节点表示为黑色节点

下面的代码实现来自于网络, 未测试
 */
public class Tree04_B_caseB2RB<V extends Comparable<V>> {
}

# GEO hash 

# 1. 二维空间索引问题

```markdown
常见的带有索引方便查找的树结构, 比如树, 跳表, 二分查找, hash表等, 他们的数据都是0维(hash表), 要么是一维(树, 跳表), 而地理空间坐标本质上是二维结构, 所以上述方式均不适合处理GEO索引问题
```



# 2. GEO hash 算法

```markdown
采用Z阶曲线, 数学中的分形几何, 数学原理参见: https://www.jianshu.com/p/7332dcb978b2
```

## 1. 二维平面拆分

```markdown
1. 采用二分法将经纬度坐标分成多个等级, 可以更高
2. 等级越高表示精度越高, 每个等级都将平面分成两部分, 
    纬线: 左边(东半球)/负角度标记为0, 右边(西半球)/正角度标记为1
    经线: 下边(南半球)/负角度标记为0, 上边(北半球)/正角度标记为1
3. 将精度和纬度的编码交叉编排在一起, 按照"偶数位放经度，奇数位放纬度"的规则

这样, 地球上任何一个坐标点都可以用不同的精度矩形来表示, 对应着不同的经纬编码,
将不同的等级由低到高串起来, 则编码越靠后精度越高, 编码越靠前精度越低, 如果两个坐标点都转成编码, 则他们的前缀重合度越高, 则他们距离越近, 他们形成的曲线就是z阶曲线, 


地球半径: 6378137 单位米
地球周长: 40075017 单位米

如下图可知, 当二分次数达到26次时, 精度可将至1m以内, 如果经纬度编到一起, 则是52个bit, 至少需要一个long类型存储
```





| 二分次数 | 宽度    | 角度编码(纬度0)                         | 高度    | 角度编码(经度0)                           |
| -------- | ------- | --------------------------------------- | ------- | ----------------------------------------- |
| 1        | 20000km | -180~0 = 0<br/>0~180 = 1                | 10000km | -90~0 = 0<br/>0~90 = 1                    |
| 2        | 10000km | -90~0 = 0<br/>0~90 = 1                  | 5000km  | -45~0 = 0<br/>0~45= 1                     |
| 3        | 5000km  | -45~0 = 0<br/>0~45= 1                   | 2500km  | -22.5~0 = 0<br/>0~22.5= 1                 |
| 4        | 2500km  | -22.5~0 = 0<br/>0~22.5= 1               | 1250km  | -11.25~0 = 0<br/>0~11.25= 1               |
| 5        | 1250km  | -11.25~0 = 0<br/>0~11.25= 1             | 625km   | -5.625~0 = 0<br/>0~5.625= 1               |
| 6        | 625km   | -5.625~0 = 0<br/>0~5.625= 1             | 313km   | -2.8125~0 = 0<br/>0~2.8125= 1             |
| 7        | 313km   | -2.8125~0 = 0<br/>0~2.8125= 1           | 156km   | -1.40625~0 = 0<br/>0~1.40625= 1           |
| 8        | 156km   | -1.40625~0 = 0<br/>0~1.40625= 1         | 78km    | -0.73125~0 = 0<br/>0~0.73125= 1           |
| 9        | 78km    | -0.73125~0 = 0<br/>0~0.73125= 1         | 39km    | -0.3515625~0 = 0<br/>0~0.3515625= 1       |
| 10       | 39km    | -0.3515625~0 = 0<br/>0~0.3515625= 1     | 20km    | -0.17578125~0 = 0<br/>0~0.17578125= 1     |
| 11       | 20km    | -0.17578125~0 = 0<br/>0~0.17578125= 1   | 10km    | -0.087890625~0 = 0<br/>0~0.087890625= 1   |
| 12       | 10km    | -0.087890625~0 = 0<br/>0~0.087890625= 1 | 4892m   | -0.0439453125~0 = 0<br/>0~0.0439453125= 1 |
| 13       | 4892m   |                                         | 2446m   |                                           |
| 14       | 2446m   |                                         | 1223m   |                                           |
| 15       | 1223m   |                                         | 611m    |                                           |
| 16       | 611m    |                                         | 306m    |                                           |
| 17       | 306m    |                                         | 153m    |                                           |
| 18       | 153m    |                                         | 76m     |                                           |
| 19       | 76m     |                                         | 38m     |                                           |
| 20       | 38m     |                                         | 19m     |                                           |
| 21       | 19m     |                                         | 10m     |                                           |
| 22       | 10m     |                                         | 5m      |                                           |
| 23       | 5m      |                                         | 2.4m    |                                           |
| 24       | 2.4m    |                                         | 1.2m    |                                           |
| 25       | 1.2m    |                                         | 0.6m    |                                           |
| 26       | 0.6m    |                                         | 0.3m    |                                           |


## 2. 编码

```markdown
上个图表中, 如果将二分26次, 分别用26个bit位表示, 经纬度放在一起总共52个bit位, 完全可以使用一个long来表示
如果仅仅使用long来保存所有的code, 则最多可以二分32次, 届时精度可达约1cm, 当然如果采用长度更长的分法, 精度将会更高
```

### 1. 数字编码

```markdown
由于是前缀对比, 所以bit位的前缀要保持对齐, 采用long高位第13(65-52)位开始存入编码, 低位如果没有计算就补0
这样就形成了一个在long范围内的一维的数, 数之间的距离越近, 则表示真实空间他们所处的点距离就越近

在redis中, 可以将(52位)long类型编码存入zset的score中, 实现geohash的功能, Redis中就是采用此方式实现的, 不过redis对其进行了优化, 具体参见redis学习项目
```

### 2. 字符编码

```markdown
由于采用long类型编码, 不够直观, 转成二进制右太长, 部分场景可能会使用字符编码
```



**Base32**

|         |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Decimal | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| Base 32 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | b    | c    | d    | e    | f    | g    |
| Decimal | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   |
| Base 32 | h    | j    | k    | m    | n    | p    | q    | r    | s    | t    | u    | v    | w    | x    | y    | z    |

```markdown
由于long类型总共52位编码有点长, 所以将其转换为base32进行编码, 每5个bit对应一个base32字符, 采用12个字符可以表示二分(12*5)次的精度

具体编码等级和实际精度对应关系如下图
```



| Base32编码长度(等级) | cell 宽度 | cell 高度 |
| -------------------- | --------- | --------- |
| 1                    | 5,000km   | 5,000km   |
| 2                    | 1,250km   | 625km     |
| 3                    | 156km     | 156km     |
| 4                    | 39.1km    | 19.5km    |
| 5                    | 4.89km    | 4.89km    |
| 6                    | 1.22km    | 0.61km    |
| 7                    | 153m      | 153m      |
| 8                    | 38.2m     | 19.1m     |
| 9                    | 4.77m     | 4.77m     |
| 10                   | 1.19m     | 0.596m    |
| 11                   | 149mm     | 149mm     |
| 12                   | 37.2mm    | 18.6mm    |


**Base36**

```markdown
其他编码方式, Base36 略
```

## 3. GEO hash 算法缺点

```markdown
1. 将二维空间近似成一维本身是一种近似算法, 在z阶曲线中, 两个不同的块交接的时候, 会有距离上的偏差, 如果是大块这种偏差会更明显, 即使他们在一维线上的距离只有1
		解决方式: 在实际应用中, 通常采用GEOHash+坐标直线计算的复合计算方式, 先用Geohash算出复合距离的所有的点, 然后通过直线计算排除误差的点
2. 采用base32的编码比较常用, 但是等级与等级之间经度相差太大(差了5个二分次数), 所以在使用中会出现低一个精度范围太小, 高一个精度范围太大的窘境, 
		解决方式: 可以采用其他方式的编码, 比如4bit一组, 或者3bit一组, 不过也会带来数据量(方格数)增加的问题
3. 比较适合存储中等数据量的坐标信息, 并不适合存储海量坐标的信息


采用更先进的S2算法, 等待学习
```



# 3. GEO算法的应用

```markdown
1. 在线GEO展示
https://ryan-miao.gitee.io/geohash-visualization/show_all.html

2. 附近坐标点的查询
```


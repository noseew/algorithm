package org.song.algorithm.base._02alg.classical.elimination.lfu;

/*
没有找到具体实现, 从网上找的一些算法描述
 */
public class LFU_LFUDA {
    /*
    基于LFU的改进算法, 其核心思想是"除了访问次数外, 还要考虑访问时间”. 这样做的主要原因是解决LFU缓存污染的问题. 
    
    https://blog.csdn.net/weixin_38569499/article/details/113771551
    LFUDA(LFU with dynamic aging), 是LFU算法对于缓存污染问题的优化算法. 它为缓存引用次数增加了"时间因子"的概念, 用来适应缓存使用场景的变化. 
    LFUDA并没有真的为每次引用记录一个时间, 这样开销太大的. LFUDA是通过引入了引用次数的"老化"机制来引入"时间因子"的. LFU会动态持有一个平均引用次数, 数值是当前所有缓存引用次数的平均值. 当平均引用次数超过了一个预定义的门限时, 会给每个引用减少引用次数. 为每个应用减少访问次数的策略是灵活的, 可扩展的, 可以使用减少固定值, 减少百分比等各种合适的策略. 
    参考论文:  A Web Proxy Cache Coherency and Replacement Approach 
    
    虽然LFU-Aging考虑时间因素, 但其算法并不直接记录数据的访问时间, 而是通过平均引用计数来标识时间. 
    LFU-Aging在LFU的基础上, 增加了一个最大平均引用计数. 当当前缓存中的数据"引用计数平均值”达到或者超过"最大平均引用计数”时, 则将所有数据的引用计数都减少. 减少的方法有多种, 可以直接减为原来的一半, 也可以减去固定的值等. 
    
    优缺点
    3.1 优点
    和LFU算法相比, LFU-Aging一定程度上解决了缓存污染的问题. 当访问缓存的场景发生变化时, LFU-Aging可以更快适应, 缓存的命中率更高
    3.2 缺点
    复杂度: LFU-Aging在LFU的基础上增加平均引用次数判断和处理, 实现上更复杂. 
    处理器开销: 平均引用次数达到门限时, 需要遍历队列或链表, 执行引用次数老化策略, 这会带来一定的开销
    
     */
    
    /*
    论文翻译
    
    针对web代理缓存系统, 提出了一种基于系统和应用的自适应缓存一致性替换方案, 以优化分布式缓存系统性能为目标. 
    我们的一致性替换方案根据一组标准为每个缓存块分配替换优先级值, 以决定删除哪个块. 
    其目标是提供对分布式缓存内存的有效利用和良好的应用程序性能. 
    
    摘要提出了一种自适应的缓存相干替换方案Web代理缓存系统, 基于关于系统和应用程序, 以优化分布式缓存系统性能为目标. 
    我们的一致性替换方案指定替换优先级每个缓存块的值, 根据一组标准来决定哪个块删除. 
    目标是提供对分布式缓存的有效利用具有良好的内存和应用程序性能. 
    
    
    1介绍
    许多研究研究了缓存替换和缓存一致性的策略;然而, 这些研究很少考虑到政策的综合效应(2,6). 
    本文提出了一种自适应的高速缓存相干替换方案Web代理缓存系统. 
    这项工作是在我们以前所做的工作的基础上进行的其中缓存替换机制说明了自适应缓存替换策略可以提高计算系统[1]的性能. 
    我们的方法结合经典一致性协议(write-update和write-invalid协议)和替换策略(LRU、LFU等)来优化整体性能(基于标准)
    如网络流量、应用程序执行时间、数据一致性等). 
    缓存一致性机制负责确定一个副本是否在分发缓存系统过期或有效. 
    同时, 它必须更新无效的副本当一个给定的站点需要一个区块时. 
    因为缓存的存储容量是固定的, 当存储空间满时, 缓存必须选择一组对象(或一组对象)为新请求的对象/块腾出空间. 
    该任务采用替换机制. 我们的方法试图改进通过分配替代的分布式缓存系统的性能优先级值要根据一组条件对每个缓存块进行选择块/对象删除. 
    要修复这个优先级, 我们需要考虑缓存的状态块. 
    此外, 我们的方案使用了一个自适应替代策略, 它查看可用的信息来决定使用什么替代技术, 而不需要空间/时间需求的比例增加. 
    
    2理论方面
    2.1一致性问题
    分布式缓存系统以一定的代价降低了延迟:每个缓存有时会向用户提供过时的页面. 
    每个本地缓存都必须以某种方式更新页面这样就可以给用户提供尽可能新鲜的页面. 
    事实上,保持缓存页面更新的问题对于缓存系统来说并不是什么新问题:
    毕竟缓存实际上只是一个巨大的分布式文件系统, 而且是分布式文件系统已经跟了我们很多年了. 
    在传统的分布式系统术语中缓存页面的更新问题称为一致性[2,3,5,6,8,11,14]. 
    具体来说, 缓存一致性问题包括将一个数据元素保存在多个数据中缓存彼此之间的当前值和主存(或本地存储器)中的值. 
    缓存一致性协议保证了系统的数据一致性读操作返回的值必须是最后写到该位置的值. 
    在那里有两类缓存一致性协议[14]:write-invalidate和write-update. 
    在write-invalidate协议中, 对一个块的写请求使所有其他共享块失效那个块的副本. 
    如果处理器向一个失效的数据块发出读请求, 就会出现一致性缺失. 
    每个对共享数据的写请求都会更新块和块的所有其他副本是共享的. 
    尽管写更新协议有较少的读失败, 但是总线上的写流量经常很高, 以至于整体性能下降. 
    已经提出了多种机制来解决缓存一致性问题问题. 多处理器系统的最佳解决方案取决于几个因素, 
    例如系统的大小(即处理器的数量), 等等. 
    
    
    2.2更换策略问题
    替换策略指定当出现新块时应该删除哪个块必须输入到已经满的缓存中;
    它的选择应该是为了确保可能在不久的将来被引用的块被保留在缓存中. 
    选择替换策略是缓存设计中最关键的问题之一, 对整个系统性能有重要影响. 
    常用的替换算法有[1,4,7,9,10,15]的缓存:
    
    先进先出(FIFO):这是最简单的方案;它很容易管理与一个FIFO队列. 当需要替换时, 在缓存处输入的第一个块内存(在队列的头部)必须被移除. 



     */
}

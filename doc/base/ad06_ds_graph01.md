# 图

## 定义

```
图的表示
图通常用一个二元组
    G=<V, E>表示, 
    V表示顶点集, 
    E表示边集. 

|V|表示顶点集中元素的个数, 即顶点数, n个顶点的图称为n阶图. |E|表示边集中元素的个数, 即边数. 

```

## 特点

### 图的分类

#### 有向图

```
有向图
    若图G中每条边都是有方向的, 则称为有向图, 顶点v1到顶点v3的弧, 记为<v1, v3>, v1称为弧尾, v3称为弧头, 


有向无环图: DAG (directed acyclic graph)
有向且无环的图

```

#### 无向图

```
无向图
    若图G中每条边都是没有方向的, 则称为无向图, 顶点v1和顶点v3之间的边, 记为(v1, v3)或(v3, v1)
    尖括号<vi, vj>表示有序对, 圆括号(vi, vj)表示无序对. 
```

#### 简单图

```
简单图
    既不含平行边也不含环的图称为简单图, 
    在无向图中, 若关联一对顶点的无向边多于一条, 则称这些边为平行边, 平行边的条数称为重数, 在有向图中, 若关联一对顶点的有向边多于一条, 并且这些边的始点和终点相同(方向一致), 则称这些边为平行边, 自环是指一条边关联的两个顶点为同一个顶点, 也就是说自己到自己有一条边, 
    
    常用学习的都是简单图

和简单图对应的是多重图(复杂图)
有平行边或自环的图
```

#### 完全图

```
完全图
    在无向图中, 若任意两个点都有一条边, 则该图称为无向完全图, 含有n个顶点的无向图, 每个顶点到其他的n-1个顶点都有边, 
        一共有n(n-1)/2条边. 
    在有向图中, 若任意两个点都有两条方向相反的两条弧, 则该图称为有向完全图, 含有n个顶点的有向图, 每个顶点发出n-1条边, 并且进来n-1条边, 
        一共有n(n-1)条边. 

```

#### 稀疏图和稠密图

```
稀疏图和稠密图
    一般来说, 若图G满足|E|<|V|×log|V|, 则称G为稀疏图. 
    有向图的边也叫弧
    稀疏图, 边/弧 < nlogn, n=定点数
```

#### 带权图 网

```
带权图 网
    带权的图称为网
```

### 概念

#### 邻接和关联

```
邻接和关联
邻接
    邻接是指顶点和顶点之间的关系, 
    用来描述两个定点是否是邻接的,
        (vi, vj)无向: vi和vj互为邻接点
        <vi, vj>有向: vi邻接到vj, vj邻接于vi
关联/依附
    关联是指边和顶点之间的关系. 
    边关联于xx顶点
```

#### 顶点的度

```
顶点的度
    顶点的度是指与该顶点相关联的边的数目, 记为TD(v). 
        入度ID(v), 出度OD(v)
    握手定理: 度数之和等于边数的两倍, 
    在有向图中, 顶点的度又分为入度和出度. 所有顶点的入度之和=出度之和=边数. 
```

#### 路径

```
路径/路径长度和距离
    路径: 接续的边的顶点构成的序列. 
    路径长度: 路径上边或弧的数目. 
    距离: 从顶点到另一顶点的最短路径长度. 


回路(环)/简单路径和简单回路
    回路(环): 第一个顶点和最后一个顶点相同的路径. 
    简单路径: 除路径起点和终点可以相同外, 其余顶点均不相同的路径. 
    简单回路: 除路径起点和终点相同外, 其余顶点均不相同的路径. 
```


#### 子图

```
子图: 一个图包含另一个图, 点和边都包含
```

#### 连通图/连通分量

```
连通图/强连通图
    在无向图中, 若对任意两个顶点, 都存在路径, 则为 连通图
    在有向图中, 若对任意两个顶点, 都存在路径, 则为 强连通图

连通分量 Connected Component
    无向图中, 图G的极大连通子图 的数量, 称为G的连通分量
    有向图中, 图G的极大连通子图 的数量, 称为G的强连通分量

        连通子图: 连通的且子图
        极大: 在增加一个边或定点, 就不连通或就不是子图
    将一个图分成 1-n个极大连通子图, 则这 1-n个极大连通子图 就是这个图的连通分量

极小连通子图
    连通的且子图
    极小: 删除一条边或一个顶点后, 就不在连通了

生成树:
    包含图所有顶点的极小连通子图
    生成树, 可以画成树的格式
生成森林:
    对于非连通图, 有各个连通分量的生成树的集合
    生成森林, 可以画成多个树/森林的格式
```

#### 权和网

```
权: 图中边或弧有相关的数, 称作权, 表示距离或者消耗
网: 带权图称为网
```


## 对应数据结构
```

```
## 运算
```
创建
深度优先遍历
广度优先遍历

```
### 图的遍历

```
避免重复访问
设置辅助数组, 标记是否已经访问过, 数组大小就是顶点表大小
0-未访问过, 1-访问过

```

#### 深度优先遍历 DFS

```
子如果未被访问过, 优先访问子邻接点, 否则访问兄弟邻接点
```

#### 广度优先遍历 BFS

```
兄弟如果未被访问过, 优先访问兄弟邻接点, 否则访问子节点
```


## 存储结构

### 邻接矩阵/数组表示法

```
数组存储分为
邻接矩阵存储, 包括4个字段
    1. 顶点数组: 保存所有顶点信息的一维数组, 元素内容自定义
    2. 邻接矩阵: 保存各个顶点间关系的二维数组, 元素是数字, 表示顶点和顶点的关系, 行列的长度就是顶点数量
        如果 顶点_i 和 顶点_j 存在边, 则二维数组(i,j)=1(如果有权, 就是权值或者无穷大), 否则=0
    3. 定点数
    4. 边数

具体存储
    1. 无向图的邻接矩阵
        在无向图中, 如果vi到vj有边, 则邻接矩阵M[i][j]=M [j][i]=1, 否则M [i][j]=0. 
        无向图邻接矩阵的特点如下. 
        1. 无向图的邻接矩阵是对称矩阵, 并且是唯一的. 无向图的邻接矩阵, 正好是一个对角矩阵
        2. 第i行或第i列非零元素的个数正好是第i个顶点的度. 
    如果无向图是个完全图, 则连接矩阵除了对角线其他都是1
    
    2. 有向图的邻接矩阵
        有向图中, 如果vi到vj有边, 则邻接矩阵M[i][j]=1, 否则M[i][j]=0
        有向图邻接矩阵的特点如下. 
        1. 有向图的邻接矩阵不一定是对称的. 
        2. 第i行非零元素的个数正好是第i个顶点的出度, 第i列非零元素的个数正好是第i个顶点的入度. 
        i表示出度, j表示入度
        i表示行, j表示列

    3. 网的邻接矩阵
        网是带权图, 需要存储边的权值, 则邻接矩阵表示为: 其中, wij表示边上的权值, ∞表示无穷大. 尖括号<vi, vj>表示有序对, 圆括号(vi, vj)表示无序对. 当i=j时, wii也可以设置为0. 


邻接矩阵表示法
    1. 邻接矩阵对于同一个图来说, 表现出来总是唯一的
优点
    1. 直观, 简单, 好理解
    2. 方便检查任意一堆顶点间是否有边
    3. 方便查找任一顶点的所有邻接点
    4. 方便找到顶点的所有度数, 包括入度和出度
缺点
    1. 增加/删除节点, 需要重建整个邻接矩阵
    2. 如果边的个数非常少, 则浪费空间, 空间只和顶点相关, 空间复杂度O(n^2), n=定点数
        对于稠密图还可以, 但是对于稀疏图
    3. 统计图中有多少条边, 比较浪费时间

```


### 链式存储

```
链式存储分为
    邻接表
    十字链表
    邻接多重表


```

```
邻接表
存储方式, 包含字段
    无向图
    1. 顶点表, 是一个一维数组, 包含所有顶点信息, 和顶点的下一个边节点的指针
    2. 边节点, 是一个单向链表, 值a=边, next=下一个边, 是顶点表节点的下一个节点, 边节点存储的信息a是, 顶点表数组的下标, 
        a=表示当前顶点节点和顶点数组下标[a]有一条边
        边节点可以有多个, 行程一个链表, 有多少个边节点主要看顶点有多少个边节点
        当链表下一个节点为null, 则表示没有下一个边了

    头节点的链表的节点个数就是该顶点度数
    
    邻接表特点(无向图)
        1. 链表中不同的节点可能表示相同的边
        2. 单链表节点顺序可变
        3. 存储空间=O(n+2e), n=节点, e=边
    
存储方式, 包含字段, 注意具体的定义方式根据语言等有所区别, 能表达意思即可
    有向图, 和无向图的区别, 入度存储(当然也可以出度存储, 逆邻接表)
    1. 顶点表, 是一个一维数组, 包含所有顶点信息, 和顶点的下一个边节点的指针
    2. 边节点, 是一个单向链表, 顶点表只记录顶点触发的边, 只记录出度边

    邻接表特点(有向图)
        1. 邻接表中边的节点是唯一的
        2. 单链表节点顺序可变
        3. 存储空间=O(n+e), n=节点, e=边

    计算出度, 就是顶点有多少个单链表节点就行, 
    计算入度, 只能遍历整个邻接表
邻接表特点
    1. 邻接表对于同一个图来说, 表现出来不一定是唯一的, 边的链表顺序不一定, 同一个图可能表示成不同的邻接表
优点
    1. 存储稀疏图, 节省空间
    2. 方便查找某个点的其他邻接点
缺点
    1. 有向图中, 计算入度需要遍历所有节点和边, (逆邻接表找出度难)
```

邻接表和邻接矩阵

```
邻接矩阵多用于稠密图
邻接表多用于稀疏图
```

```
十字链表 和 邻接多重表
    邻接表, 和逆邻接表, 
        对于有向图, 求节点的度比较困难, 为此如果能将出度和入度都存入邻接表这就是十字链表
        对于无向图, 每条边都要存储两遍, 为此使用邻接多重表

十字链表
    将邻接表和逆邻接表结合起来


```

# 应用

## 拓扑排序

```
拓扑排序
    前置知识:
        AOV网: 
        大工程分为多个子工程的集合, 而这些子工程之间有相互依赖关系, 只有子工程A完成后才能进行子工程B
        使用有向无环图来表示这样的工程关系, 这样的图称为AOV网
        其中, 图的顶点表示一个子工程, 有向图的方向表示子工程的依赖关系
        拓扑排序就是将 AOV网中, 按照依赖关系排除并输出
    条件: 1. 有向无环图; 2. 排序结果并不唯一, 因为会存在没有相互依赖关系的顶点

    实现
        一 卡恩算法
```

### 卡恩算法

```
一 卡恩算法
思路: 
    1. 找到图中所有入度为0的顶点的集合, 删除并记录他们
    2. 剩下的顶点集合中, 继续执行1的步骤; 此顺序删除的顶点就是拓扑排序的结果
    注意: 如果删除的顶点数量不等于原图顶点数, 则说明图中存在环
    具体的实现参照卡恩算法

```

## 最小生成树 (minimal spanning tree)

### prim算法

```
prim算法, 计算最小生成树
1. 切分定理
    用一条线将图分割成两个部分, 该条线所穿过的1条或多条边中, 权重最小的那条边一定是最小生成树中的一条边
    
prim算法就是根据切分定理来实现的
集合S是切分已计算的顶点集合, 
1. 从某一个顶点开始切割, 将该顶点记录在S中, 则从S和该图其他顶点之间(非S)的边选出权重最小的边, 加入最小生成树集合中
2. 以此类推, 重复步骤1, 直到最小生成树中的边数等于该图顶点数-1, 则最小生成树完成
注意: 过程中需要防止边的重复添加
```

### kruskal算法

```
kruskal算法, 计算最小生成树
1. 根据prim的切分定理, 能得到
    1. 所有边的集合中, 权重最小的(和次小的)一定是最小生成树中的一条边
        根据切分定理, 最小的和次小的一定会在某次切分中出现且是该次切分中最小的边
    2. 去掉那些能够构成环的边, 则这些最小的边就是最小生成树的边(最小边数要等于顶点数-1)
        最小边中, 可能会出现环, 所以去掉那些环, 之后的边依然满足1

kruskal算法, 就是将所有的边从小到大排序, 去除掉能构成环的边之后, 边数到达定点数-1, 既是最小生成树
如何判断是否会构成环呢? 采用并查集
```



## 最短路径 (Shortest path)

```
适用于 有向图/无向图, 有权图/无权图, 无负环的, 
无权图相当于每条边的权重都是1


```

**单源最短路径**

```
从一个顶点出发到其他顶点的路径
```

### dijkstra

```
从一个顶点到其他顶点的最短路径, 不支持有负权边的图, 该算法不支持
效率 O(ElogV)

算法思路
    算法思路模拟: 将多个石头用绳线连起来, 线的长度就是权重, 将其平放在桌面上, 如此就构成了一个图
    1. 以其中一个石头(顶点)为起点V1, 慢慢向上提起, 直到有下一个石头V2被带起来; 此时顶点和下一个石头就构成了两个顶点间的最短路径
        下一个被提起的石头, 权重一定是接下来中最小的
    2. 重复第一步, 下一个被带起来的石头V3, 就构成了V1到V3的最短路径

算法记录: 
1. 记录一个顶点V1到其他顶点的所有最短路径的表

    开始顶点 | 目标顶点 | 最短路径 | 最短路径值
    V1     | V2      | V1-V2   | 1
    V1     | V3      | 无穷大   | 无穷大
    其他省略 ...

2. 按照算法思路, 先找到V1第一个提起的顶点V2, 然后将表中的V1-V2路径记录下路径, 并标记为最短路径, 
    1. 标记为最短路径的标志是, 该顶点被提起离开桌面; 
        算法中确定下一个被提起的石头就是在上表中, 除了已经标记了最短路径的其他最短路路径值中取最小的 
    2. 更新最短路径条件是, 随着每次新的石头被提起, 发现新的路径指向目标顶点, 且新的路径长度小于原来路径长度
        比如 V1-V3 = 10, 随着V2被提起, 发现 V1-V2-V3 = 7, 则V1-V3的路径更新为 V1-V2-V3

松弛操作:
    松弛操作其实就是更新最短路径和其权值
    优先能确定的路径权值, (比如V1-V3, 他们是直接相连的, 但是他们的权值并不一定是最短路径), 
    在提起石头的过程中, 新的路径被发现, 发现 V1-V2-V3 比 V1-V3 权值更短, 相当于 V1-V3 这根线边松了, 取而代之的是 V1-V2-V3 这根线变紧了

```

### bellman-ford

```
支持负权边, 还能监测出是否有负权环
复杂度O(EV), 比 dijkstra 要高, 不过它支持负权边

算法原理, 基于 dijkstra 的松弛操作实现: 假设图有n条边, 则对图 每条边 进行最多n-1次松弛操作即可

原理讲解
1. 如果第一次松弛的边from还没有确定边权值, 则松弛失败, 等待下次松弛
2. 由于每次松弛都是对所有边进行松弛, 因此任何一点总会在某一次中计算到权值(顶点到当前点), 类似于冒牌排序, 
3. 类似于冒牌排序, 最终所有的边都会进行一次类似"正序"的松弛操作, 从而计算出所有的最短路径


```

**多源最短路径**

```
从多个顶点出发到其他顶点的路径
```

### floyd




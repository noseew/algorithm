# 算法思想


```
递推 顺推/逆推
枚举 穷举
递归
分治
贪婪/贪心
试探
模拟
动态规划
```

# 递归

```
    一个调用方法占用一个栈空间
    递归需要有一个结束递归的条件, 边界条件, 也叫递归基
    
    效率不一定是最优的, 代码比较简洁
    
    递归思想: 
    第一部: 拆解问题
    把规模大问题拆解成规模较小的问题, 把规模较小的问题, 拆解为更小一直到不能再拆解的时候
    第二部: 求解
    有最小规模问题的解不断得出更大规模问题的解
    
    凡是可以利用上述思路解决的问题, 都可以利用递归来实现
    1. 链表: 链表就是链表包含链表
    2. 二叉树: 二叉树包含二叉树
```
```
    递归转非递归
    1. 所有的递归都可以转成非递归, 也就是通过自定义栈实现 
    2. 采用重复利用某个栈内的变量值
```


```
递归常用算法问题
菲波那切数列
树遍历
汉诺塔
跳台阶/爬楼梯
换酒瓶
```
     
## 尾调用

```
在方法尾部, 在调用别的方法, 这就是尾调用
单独分出来是因为, 部分编译器会将尾调用优化, 优化的结果是
将当前方法占空间利用到尾调用的新的栈空间, 也就是不用开辟新的栈空间
注意: 对便一起的要求是, 占空间可以动态扩张, 注意: JVM好像不支持
```

### 尾递归

```
尾递归是尾调用的一种特殊形式, 
编译器对尾递归的优化更加简单, 因为尾调用方法和当前方法占空间大小相同
尾递归的优化相当于将递归变成循环, 而不是重复开辟占空间
注意: JVM支持尾递归优化
```

# 回溯

# 贪心 greedy

```
贪心算法
贪心策略并不一定能得到全局最优解
- 因为一般并没有测试所有的可能性, 容易过早做出决定, 所以没法达到最优解
- 贪图眼前局部的利益最大化, 看不到长远未来, 走一步看一步

优点: 简单, 高效, 不需要穷举所有可能, 通常作为其他算法的辅助算法来使用
缺点: 不从整体上考虑其他可能, 每次都是局部最优解, 不会再回溯, 因此很少情况会得到最优解

```

```
贪心算法常见解决问题(由于不是全局最优解, 所以使用全局最优解可以使用动态规划)

海盗最优装载
    每次选择重量最小的， 选完就完了
零钱兑换
    每次选择面值最大的， 可以重复选择
0-1背包
    按照指定纬度(价值, 重量, 性价比), 进行选择
分发饼干
用最少量的箭引爆气球
买股票的最佳时机
种花问题
分发糖果


哈夫曼树
最小生成树
最短路径
```

# 分治

# 动态规划
# 算法思想


```
递推 顺推/逆推
枚举 穷举
递归
分治
贪婪/贪心
试探
模拟
动态规划
```

# 递归

```
    一个调用方法占用一个栈空间
    递归需要有一个结束递归的条件, 边界条件, 也叫递归基
    
    效率不一定是最优的, 代码比较简洁
    
    递归思想: 
    第一部: 拆解问题
    把规模大问题拆解成规模较小的问题, 把规模较小的问题, 拆解为更小一直到不能再拆解的时候
    第二部: 求解
    有最小规模问题的解不断得出更大规模问题的解
    
    凡是可以利用上述思路解决的问题, 都可以利用递归来实现
    1. 链表: 链表就是链表包含链表
    2. 二叉树: 二叉树包含二叉树
```
```
    递归转非递归
    1. 所有的递归都可以转成非递归, 也就是通过自定义栈实现 
    2. 采用重复利用某个栈内的变量值
```


```
递归的应用

菲波那切数列
树遍历
汉诺塔
跳台阶/爬楼梯
换酒瓶
```
     
## 尾调用

```
在方法尾部, 在调用别的方法, 这就是尾调用
单独分出来是因为, 部分编译器会将尾调用优化, 优化的结果是
将当前方法占空间利用到尾调用的新的栈空间, 也就是不用开辟新的栈空间
注意: 对便一起的要求是, 占空间可以动态扩张, 注意: JVM好像不支持
```

### 尾递归

```
尾递归是尾调用的一种特殊形式, 
编译器对尾递归的优化更加简单, 因为尾调用方法和当前方法占空间大小相同
尾递归的优化相当于将递归变成循环, 而不是重复开辟占空间
注意: JVM支持尾递归优化
```

# 回溯

# 贪心 greedy

```
贪心算法
贪心策略并不一定能得到全局最优解
- 因为一般并没有测试所有的可能性, 容易过早做出决定, 所以没法达到最优解
- 贪图眼前局部的利益最大化, 看不到长远未来, 走一步看一步

优点: 简单, 高效, 不需要穷举所有可能, 通常作为其他算法的辅助算法来使用
缺点: 不从整体上考虑其他可能, 每次都是局部最优解, 不会再回溯, 因此很少情况会得到最优解

```

```
贪心算法的应用(由于不是全局最优解, 所以使用全局最优解可以使用动态规划)

海盗最优装载
    每次选择重量最小的， 选完就完了
零钱兑换
    每次选择面值最大的， 可以重复选择
0-1背包
    按照指定纬度(价值, 重量, 性价比), 进行选择
分发饼干
用最少量的箭引爆气球
买股票的最佳时机
种花问题
分发糖果


哈夫曼树
最小生成树
最短路径
```

# 分治 divide and conquer

```
分治, 分而治之, 一般步骤是
1. 将原问题分解成若干个规模较小的子问题, 子问题和原问题的结构一样, 只是规模不一样
2. 子问题又不管的分解成规模更小的子问题, 直到不能再分解, 直到可以轻易计算出子问题的解
3. 利用子问题的解推导出原问题的解
因此分治策略非常适合用递归
注意: 子问题之间是相互独立的


分值策略通常遵守通用模式
- 解决规模为n的问题, 分解成a个规模为n/b的子问题, 然后再O(n^d)时间内将子问题的解合并起来
- 算法运行时间为: T(n)=aT(n/b) + O(n^d), a>0, b>1, d>=0, 也就是 所有子问题时间之和+合并的时间

```

```
分治的应用

最大连续子序列和
快排
归并排序
krartsuba大数乘法
```

# 动态规划 dynamic programming

```
简称DP, 是求解最优化问题的一种常用策略

通常使用步骤, 一步步优化, 直到最后的完成态的DP
1. 采用暴力递归, 自顶向下解决问题, 
    例如, 斐波那契树
2. 记忆化搜索, 暴力递归可能会出现重叠子问题重复计算, 所以需要计算结果复用
3. 递推(递归改成非递归, 迭代), 自底向上

动态规划常规步骤思路

```
